# move (usage-related) tags to the right end, and 
# if there are more than one, keep the most informative one
# moving algorithm from Karttunen, Beesley "2-level rule compiler" 4.3 (via Mans Hulden via Francis Tyers) 

define RTag [ "+Use/Rare" ] ;          # norm, but rare 
define HTag [ "+Use/Hyp" ] ;           # norm, but so rare that norm is probaly wrong
define NTag [ "+Use/NotNorm" ] ;       # not norm, but sometimes used
define CTag [ "+Use/CommonNotNorm" ] ; # not norm, and used more than norm
define ETag [ "+Emph" ] ;              # emphasized form (mina, sina, tema, meie, teie, nemad) 

define Hyphen [ "-" ] ;  # in future, this will be smth different? 
define WB [Hyphen | "#" | .#.] ;  # just to make sure that moving does not cross word boundary in compounds

define MoveR [  [..] -> RTag || RTag \WB* _ WB .o. RTag -> 0 || _ \WB* RTag WB ];
define MoveH [  [..] -> HTag || HTag \WB* _ WB .o. HTag -> 0 || _ \WB* HTag WB ];
define MoveN [  [..] -> NTag || NTag \WB* _ WB .o. NTag -> 0 || _ \WB* NTag WB ];
define MoveC [  [..] -> CTag || CTag \WB* _ WB .o. CTag -> 0 || _ \WB* CTag WB ];
define MoveE [  [..] -> ETag || ETag \WB* _ WB .o. ETag -> 0 || _ \WB* ETag WB ];

# move all usage-related tags to the right end 
define MoveTag [MoveR .o. MoveH .o. MoveN .o. MoveC .o. MoveE] ;

# if 2 usage-related tags are adjacent, remove the less informative one
# 
# we currently deal only with this instance:
# remove +Use/Rare if +Use/Hyp or +Use/NotNorm are also present 

define RemRTag1 RTag -> 0 || [NTag | HTag] _ ; # 
define RemRTag2 RTag -> 0 || _ [NTag | HTag] ; # 
define RemRTag [RemRTag1 .o. RemRTag2] ; 

regex [MoveTag .o. RemRTag].i ;
